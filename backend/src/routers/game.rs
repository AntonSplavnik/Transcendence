use salvo::prelude::*;
use serde::{Serialize, Deserialize};
use diesel::prelude::*;

use crate::prelude::*;
use crate::schema::{user_stats, game_history};
use crate::models::{UserStats, NewUserStats, UpdateUserStats, GameHistory, NewGameHistory};

#[derive(Serialize, ToSchema)]
pub struct GameStartResponse {
    pub total_games: i32,
}

/// Start a new game and increment the games_played counter
#[endpoint(
    tags("game"),
    responses(
        (status_code = 200, description = "Game started successfully", body = GameStartResponse),
        (status_code = 401, description = "Unauthorized - User not authenticated"),
        (status_code = 500, description = "Internal server error"),
    )
)]
pub async fn increment_played_games(depot: &mut Depot) -> Result<Json<GameStartResponse>, StatusError> {
    let user_id = depot.user_id();
    
    let mut conn = crate::db::get()
        .map_err(|e| {
            tracing::error!("Database connection error: {}", e);
            StatusError::internal_server_error().brief("Database connection failed")
        })?;

    // Try to find existing stats
    let stats = user_stats::table
        .filter(user_stats::user_id.eq(user_id))
        .first::<UserStats>(&mut conn)
        .optional()
        .map_err(|e| {
            tracing::error!("Database query error: {}", e);
            StatusError::internal_server_error().brief("Failed to query user stats")
        })?;

    let total_games = if let Some(mut stats) = stats {
        // Update existing stats
        stats.games_played += 1;
        diesel::update(user_stats::table.filter(user_stats::user_id.eq(user_id)))
            .set(user_stats::games_played.eq(stats.games_played))
            .execute(&mut conn)
            .map_err(|e| {
                tracing::error!("Failed to update stats: {}", e);
                StatusError::internal_server_error().brief("Failed to update stats")
            })?;
        stats.games_played
    } else {
        // Create new stats - timestamps will be generated by DB DEFAULT
        let now = chrono::Utc::now().naive_utc();
        let new_stats = NewUserStats {
            user_id,
            games_played: 1,
            created_at: now,
            updated_at: now,
            total_kills: 0,
            total_time_played: 0,
            last_game_kills: 0,
            last_game_time: 0,
            last_game_at: None,
        };
        diesel::insert_into(user_stats::table)
            .values(&new_stats)
            .execute(&mut conn)
            .map_err(|e| {
                tracing::error!("Failed to create stats: {}", e);
                StatusError::internal_server_error().brief("Failed to create stats")
            })?;
        1
    };

    Ok(Json(GameStartResponse { total_games }))
}

// ===== END GAME ENDPOINT =====

#[derive(Deserialize, ToSchema)]
pub struct EndGameInput {
    pub kills: i32,
    pub time_played: i32, // in seconds
}

#[derive(Serialize, ToSchema)]
pub struct EndGameResponse {
    pub success: bool,
    pub total_kills: i32,
    pub total_time_played: i32,
}

/// End a game and record stats (kills, time played)
#[endpoint(
    tags("game"),
    responses(
        (status_code = 200, description = "Game stats recorded successfully", body = EndGameResponse),
        (status_code = 401, description = "Unauthorized - User not authenticated"),
        (status_code = 500, description = "Internal server error"),
    )
)]
pub async fn end_game(
    json: JsonBody<EndGameInput>,
    depot: &mut Depot,
) -> Result<Json<EndGameResponse>, StatusError> {
    let user_id = depot.user_id();
    let input = json.into_inner();
    
    let mut conn = crate::db::get()
        .map_err(|e| {
            tracing::error!("Database connection error: {}", e);
            StatusError::internal_server_error().brief("Database connection failed")
        })?;

    // Get current stats
    let stats = user_stats::table
        .filter(user_stats::user_id.eq(user_id))
        .first::<UserStats>(&mut conn)
        .optional()
        .map_err(|e| {
            tracing::error!("Database query error: {}", e);
            StatusError::internal_server_error().brief("Failed to query user stats")
        })?;

    let (new_total_kills, new_total_time) = if let Some(stats) = stats {
        // Update existing stats
        let new_total_kills = stats.total_kills + input.kills;
        let new_total_time = stats.total_time_played + input.time_played;
        let now = chrono::Utc::now().naive_utc();

        let update = UpdateUserStats {
            games_played: None, // Already incremented by start_game
            total_kills: Some(new_total_kills),
            total_time_played: Some(new_total_time),
            last_game_kills: Some(input.kills),
            last_game_time: Some(input.time_played),
            last_game_at: Some(now),
            updated_at: now,
        };

        diesel::update(user_stats::table.filter(user_stats::user_id.eq(user_id)))
            .set(&update)
            .execute(&mut conn)
            .map_err(|e| {
                tracing::error!("Failed to update stats: {}", e);
                StatusError::internal_server_error().brief("Failed to update stats")
            })?;

        (new_total_kills, new_total_time)
    } else {
        // Should not happen (start_game creates the record), but handle it
        let now = chrono::Utc::now().naive_utc();
        let new_stats = NewUserStats {
            user_id,
            games_played: 1,
            created_at: now,
            updated_at: now,
            total_kills: input.kills,
            total_time_played: input.time_played,
            last_game_kills: input.kills,
            last_game_time: input.time_played,
            last_game_at: Some(now),
        };

        diesel::insert_into(user_stats::table)
            .values(&new_stats)
            .execute(&mut conn)
            .map_err(|e| {
                tracing::error!("Failed to create stats: {}", e);
                StatusError::internal_server_error().brief("Failed to create stats")
            })?;

        (input.kills, input.time_played)
    };

    // Record game in history table
    let now = chrono::Utc::now().naive_utc();
    let new_history = NewGameHistory {
        user_id,
        kills: input.kills,
        time_played: input.time_played,
        played_at: now,
    };

    diesel::insert_into(game_history::table)
        .values(&new_history)
        .execute(&mut conn)
        .map_err(|e| {
            tracing::error!("Failed to insert game history: {}", e);
            StatusError::internal_server_error().brief("Failed to record game history")
        })?;

    Ok(Json(EndGameResponse {
        success: true,
        total_kills: new_total_kills,
        total_time_played: new_total_time,
    }))
}

// ===== GET GAME HISTORY ENDPOINT =====

#[derive(Serialize, ToSchema)]
pub struct GameHistoryItem {
    pub id: i32,
    pub kills: i32,
    pub time_played: i32,
    pub played_at: String,
}

/// Get all games played by the user
#[endpoint(
    tags("game"),
    responses(
        (status_code = 200, description = "Game history retrieved successfully", body = Vec<GameHistoryItem>),
        (status_code = 401, description = "Unauthorized - User not authenticated"),
        (status_code = 500, description = "Internal server error"),
    )
)]
pub async fn get_history(depot: &mut Depot) -> Result<Json<Vec<GameHistoryItem>>, StatusError> {
    let user_id = depot.user_id();
    
    let mut conn = crate::db::get()
        .map_err(|e| {
            tracing::error!("Database connection error: {}", e);
            StatusError::internal_server_error().brief("Database connection failed")
        })?;

    let history: Vec<GameHistory> = game_history::table
        .filter(game_history::user_id.eq(user_id))
        .order(game_history::played_at.desc())
        .load(&mut conn)
        .map_err(|e| {
            tracing::error!("Database query error: {}", e);
            StatusError::internal_server_error().brief("Failed to query game history")
        })?;

    let response = history
        .into_iter()
        .map(|h| GameHistoryItem {
            id: h.id,
            kills: h.kills,
            time_played: h.time_played,
            played_at: h.played_at.format("%Y-%m-%d %H:%M").to_string(),
        })
        .collect();

    Ok(Json(response))
}

pub fn router(path: impl Into<String>) -> Router {
    Router::with_path(path.into())
        .requires_user_login()
        .push(Router::with_path("start").post(increment_played_games))
        .push(Router::with_path("end").post(end_game))
        .push(Router::with_path("history").get(get_history))
}
