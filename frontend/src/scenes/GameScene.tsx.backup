import { useEffect, useRef } from 'react'
import { Engine, Scene, FreeCamera, Vector3, HemisphericLight, MeshBuilder, StandardMaterial, Color3 } from '@babylonjs/core'

function GameScene() {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const engineRef = useRef<Engine | null>(null)
  const sceneRef = useRef<Scene | null>(null)

  useEffect(() => {
    if (!canvasRef.current) return

    // Cr√©er le moteur Babylon.js
    const engine = new Engine(canvasRef.current, true)
    engineRef.current = engine

    // Cr√©er la sc√®ne
    const scene = new Scene(engine)
    sceneRef.current = scene

    // Lumi√®re
    new HemisphericLight('light', new Vector3(0, 1, 0), scene)

    // Grid configuration
    const GRID_SIZE = 20  // nombre de cases par c√¥t√©
    const TILE_SIZE = 1   // taille d'une case en unit√©s Babylon
    const MAP_SIZE = GRID_SIZE * TILE_SIZE

    // Map: simple square ground
    const ground = MeshBuilder.CreateGround('ground', { width: MAP_SIZE, height: MAP_SIZE }, scene)
    const groundMat = new StandardMaterial('groundMat', scene)
    groundMat.diffuseColor = new Color3(0.15, 0.45, 0.15)
    ground.material = groundMat

    // Create grid lines
    const gridLines: any[] = []
    const lineColor = new Color3(0.2, 0.6, 0.2)
    
    // Vertical lines
    for (let i = 0; i <= GRID_SIZE; i++) {
      const x = -MAP_SIZE / 2 + i * TILE_SIZE
      const points = [
        new Vector3(x, 0.01, -MAP_SIZE / 2),
        new Vector3(x, 0.01, MAP_SIZE / 2)
      ]
      const line = MeshBuilder.CreateLines(`gridV${i}`, { points }, scene)
      line.color = lineColor
      gridLines.push(line)
    }
    
    // Horizontal lines
    for (let i = 0; i <= GRID_SIZE; i++) {
      const z = -MAP_SIZE / 2 + i * TILE_SIZE
      const points = [
        new Vector3(-MAP_SIZE / 2, 0.01, z),
        new Vector3(MAP_SIZE / 2, 0.01, z)
      ]
      const line = MeshBuilder.CreateLines(`gridH${i}`, { points }, scene)
      line.color = lineColor
      gridLines.push(line)
    }

    // Walls (4 thin boxes around the map)
    const wallThickness = 0.2
    const wallHeight = 1
    const half = MAP_SIZE / 2

    const wallOptionsH = { width: MAP_SIZE + wallThickness * 2, height: wallHeight, depth: wallThickness }
    const wallOptionsV = { width: wallThickness, height: wallHeight, depth: MAP_SIZE }

    const wallN = MeshBuilder.CreateBox('wallN', wallOptionsH, scene)
    wallN.position = new Vector3(0, wallHeight / 2, -half - wallThickness / 2)
    const wallS = MeshBuilder.CreateBox('wallS', wallOptionsH, scene)
    wallS.position = new Vector3(0, wallHeight / 2, half + wallThickness / 2)
    const wallW = MeshBuilder.CreateBox('wallW', wallOptionsV, scene)
    wallW.position = new Vector3(-half - wallThickness / 2, wallHeight / 2, 0)
    const wallE = MeshBuilder.CreateBox('wallE', wallOptionsV, scene)
    wallE.position = new Vector3(half + wallThickness / 2, wallHeight / 2, 0)

    const wallMat = new StandardMaterial('wallMat', scene)
    wallMat.diffuseColor = new Color3(0.3, 0.3, 0.3)
    wallN.material = wallMat
    wallS.material = wallMat
    wallW.material = wallMat
    wallE.material = wallMat

    // Helper functions for grid-based positioning
    const gridToWorld = (gridX: number, gridY: number): Vector3 => {
      const x = -MAP_SIZE / 2 + gridX * TILE_SIZE + TILE_SIZE / 2
      const z = -MAP_SIZE / 2 + gridY * TILE_SIZE + TILE_SIZE / 2
      return new Vector3(x, 0.3, z)
    }

    const worldToGrid = (pos: Vector3): { x: number, y: number } => {
      const x = Math.floor((pos.x + MAP_SIZE / 2) / TILE_SIZE)
      const y = Math.floor((pos.z + MAP_SIZE / 2) / TILE_SIZE)
      return { x: Math.max(0, Math.min(GRID_SIZE - 1, x)), y: Math.max(0, Math.min(GRID_SIZE - 1, y)) }
    }

    // Player: simple sphere, positioned on grid
    const playerGridPos = { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2) }
    const player = MeshBuilder.CreateSphere('player', { diameter: 0.6 }, scene)
    player.position = gridToWorld(playerGridPos.x, playerGridPos.y)
    const playerMat = new StandardMaterial('playerMat', scene)
    playerMat.diffuseColor = new Color3(0.9, 0.2, 0.2)
    player.material = playerMat

    // Enemies: spawn at fixed positions (5 enemies)
    interface Enemy {
      mesh: any
      gridPos: { x: number, y: number }
      hp: number
    }

    const enemies: Enemy[] = []
    const enemySpawnPoints = [
      { x: 5, y: 5 },
      { x: 15, y: 5 },
      { x: 5, y: 15 },
      { x: 15, y: 15 },
      { x: 10, y: 3 }
    ]

    const enemyMat = new StandardMaterial('enemyMat', scene)
    enemyMat.diffuseColor = new Color3(0.8, 0.1, 0.8) // Purple enemies

    enemySpawnPoints.forEach((spawnPos, index) => {
      const enemyMesh = MeshBuilder.CreateSphere(`enemy${index}`, { diameter: 0.5 }, scene)
      enemyMesh.position = gridToWorld(spawnPos.x, spawnPos.y)
      enemyMesh.material = enemyMat

      enemies.push({
        mesh: enemyMesh,
        gridPos: { x: spawnPos.x, y: spawnPos.y },
        hp: 3
      })
    })

    // Cam√©ra fixe qui suit le joueur (top-down view avec inclinaison, plus √©loign√©e)
    const cameraOffsetY = 15  // hauteur
    const cameraOffsetZ = -10 // recul
    const camera = new FreeCamera('camera', new Vector3(0, cameraOffsetY, cameraOffsetZ), scene)
    camera.setTarget(player.position)
    camera.attachControl(canvasRef.current, true)

    // Simple keyboard controls to move the player (top-down on X/Z)
    const inputState: { [key: string]: boolean } = {}
    const keyDown = (e: KeyboardEvent) => { inputState[e.key.toLowerCase()] = true }
    const keyUp = (e: KeyboardEvent) => { inputState[e.key.toLowerCase()] = false }
    window.addEventListener('keydown', keyDown)
    window.addEventListener('keyup', keyUp)

    // Boucle de rendu
    engine.runRenderLoop(() => {
      // movement (smooth continuous movement for roguelite feel)
      const speed = 0.04
      const p = player.position
      if (inputState['arrowup'] || inputState['w'] || inputState['z']) { p.z -= speed }
      if (inputState['arrowdown'] || inputState['s']) { p.z += speed }
      if (inputState['arrowleft'] || inputState['a'] || inputState['q']) { p.x -= speed }
      if (inputState['arrowright'] || inputState['d']) { p.x += speed }

      // clamp inside map bounds
      const bound = half - 0.3
      player.position.x = Math.min(bound, Math.max(-bound, player.position.x))
      player.position.z = Math.min(bound, Math.max(-bound, player.position.z))

      // Update player grid position (useful for collision/logic later)
      const currentGrid = worldToGrid(player.position)
      playerGridPos.x = currentGrid.x
      playerGridPos.y = currentGrid.y

      // Simple enemy AI: move towards player (very slow for now)
      enemies.forEach(enemy => {
        if (!enemy.mesh) return

        // Calculate direction to player
        const dx = player.position.x - enemy.mesh.position.x
        const dz = player.position.z - enemy.mesh.position.z
        const distance = Math.sqrt(dx * dx + dz * dz)

        // Move towards player if not too close
        if (distance > 0.5) {
          const enemySpeed = 0.015 // Slower than player
          enemy.mesh.position.x += (dx / distance) * enemySpeed
          enemy.mesh.position.z += (dz / distance) * enemySpeed

          // Update enemy grid position
          const enemyGrid = worldToGrid(enemy.mesh.position)
          enemy.gridPos.x = enemyGrid.x
          enemy.gridPos.y = enemyGrid.y
        }
      })

      // Update camera to follow player (maintain offset for angled view)
      camera.position.x = player.position.x
      camera.position.y = player.position.y + cameraOffsetY
      camera.position.z = player.position.z + cameraOffsetZ
      camera.setTarget(player.position)

      scene.render()
    })

    // WebSocket vers backend Rust (TODO: remplacer par l'URL r√©elle)
    // const ws = new WebSocket('ws://localhost:8080/ws')
    // ws.onmessage = (event) => { /* handle game state updates */ }

    // Cleanup
    // Cleanup
    return () => {
      window.removeEventListener('keydown', keyDown)
      window.removeEventListener('keyup', keyUp)
      scene.dispose()
      engine.dispose()
    }
  }, [])

  return (
    <div style={{ width: '100vw', height: '100vh', position: 'relative' }}>
      <canvas ref={canvasRef} style={{ width: '100%', height: '100%' }} />
      {/* HUD React (vie, XP, chat, etc.) */}
      <div style={{ position: 'absolute', top: 10, left: 10, color: 'white', background: 'rgba(0,0,0,0.5)', padding: '10px' }}>
        <div>‚ù§Ô∏è Vie: 100</div>
        <div>‚≠ê XP: 0</div>
        <div>üïê Timer: 0:00</div>
      </div>
    </div>
  )
}

export default GameScene
